const { spawn } = require('child_process');

const iface = 'wlan0';
const monIface = 'wlan0mon';

const scanTimeout = 10; // sec - continue scan (seconds) after found at least one open point
const storageDir = './logs/';

/**
 * check and init monitor mode
 * @constructor
 */
let InitMonitorMode = async function(){

    // check if monitor mode is enabled
    let isMonitorModeEnabled = async function(){

        return new Promise(function(res, rej){

            let ifconfig = spawn('ifconfig', [monIface]);

            let parseResult = function(data){
                data = data.toString();
                let notFound1 = data.indexOf('Device not found');
                let notFound2 = data.indexOf('does not exist');

                if (notFound1 >= 0 || notFound2 >= 0) {
                    return false;
                } else {
                    return true;
                }
            };

            ifconfig.stdout.on('data', data => { res(parseResult(data)); });
            ifconfig.stderr.on('data', data => { res(parseResult(data)); });
        });
    };

    // enable monitor mode
    let enableMonitorMode = async function(){
        return new Promise(function(res, rej){
            let airmonStart = spawn('airmon-ng', ['start', iface]);
            airmonStart.on('close', code => {
                res(code);
            });
            airmonStart.on('error', err => {
                rej(err);
            });
        });
    };

    // check kill
    let checkKill = async function(){
        return new Promise(function(res, rej){
            let airmonKill = spawn('airmon-ng', ['check', 'kill']);
            airmonKill.on('close', code => { res(true); });
        });
    };

    // check & enable monitor mode
    let start = async () => {
        let _isMonitorModeEnabled = await isMonitorModeEnabled();

        if (!_isMonitorModeEnabled) {

            // enable monitor mode
            await enableMonitorMode();

            _isMonitorModeEnabled = await isMonitorModeEnabled();

            if (_isMonitorModeEnabled) {
                await checkKill();
                return Promise.resolve(true);
            } else {
                return Promise.resolve(false);
            }
        } else {
            await checkKill();
            return Promise.resolve(true);
        }
    };

    return Promise.resolve({
        'start': start,
        'checkKill': checkKill
    });
};

/**
 * get points from output data
 * @param data
 * @returns {IterableIterator<{bssid: string, ch: string, pwr: string, data: string, essid: string}>}
 */
let parseData = function* (data) {
    let lines = data.split("\n");
    for (let line of lines) {
        let _parts = line.trim().split('  ');
        let parts = [];
        for (let i in _parts) {
            if (!_parts.hasOwnProperty(i) || _parts[i].trim() === '') { continue; }
            parts.push(_parts[i].trim());
        }

        // OPN point
        if (parts.length === 9
            && parts[0].indexOf(':') === 2
            && parts[7] === 'OPN'
        ) {
            yield {
                'bssid': parts[0],
                'ch': parts[5],
                'pwr': parts[1],
                'data': parts[3],
                'essid': parts[8]
            };

        } else if (parts.length === 8
            && parts[0].indexOf(':') === 2
            && parts[6].indexOf('OPN') > 0
        ) {
            yield {
                'bssid': parts[0],
                'ch': parts[5],
                'pwr': parts[1],
                'data': parts[3],
                'essid': parts[7]
            };
        }
    }
};

let getOpenPoint = async () => {

    let airodump = spawn('airodump-ng', [monIface]);

    let openPoints = [];
    let _timeout = null;

    // collect openPoints
    let processOutput = async (data) => {
        data = data.toString();

        for (let _point of parseData(data)) {
            let isExists = false;
            for (let i in openPoints) {
                if (!openPoints.hasOwnProperty(i)) { continue; }

                if (openPoints[i].bssid === _point.bssid) {
                    isExists = true;

                    // update
                    openPoints[i] = _point;
                }
            }

            // add new
            if (!isExists) {
                openPoints.push(_point);
            }
        }

        // found open point(s) - kill proc
        if (openPoints.length > 0
            && !_timeout
        ) {
            _timeout = setTimeout(() => {
                // kill airodump process
                airodump.stdin.end();
                airodump.kill();
            }, scanTimeout * 1000);
        }
    };

    return new Promise(async (res, rej) => {

        airodump.stdout.on('data', async (data) => { await processOutput(data); });
        airodump.stderr.on('data', async (data) => { await processOutput(data); });

        airodump.on('error', (err) => { console.log('ERROR', err); });

        // airodump closed - sort found points & take one
        airodump.on('close', (code) => {
            let point = null;

            if (openPoints.length > 0) {
                openPoints.sort((a, b) => { return a.data < b.data; });
                point = openPoints[0];
            }

            res(point);
        });
    });
};

/**
 * capture traffic
 * @param point
 * @returns {Promise<any>}
 */
let capture = async (point) => {

    let MonitorMode = await InitMonitorMode();
    await MonitorMode.checkKill();

    let filepath = storageDir +'open-'+ point.essid;

    let airodump = spawn('airodump-ng', ['-c', point.ch, '--bssid', point.bssid, '-w', filepath, '--output-format', 'pcap', monIface]);

    let noPiontsTimeout = null;

    return new Promise((res, rej) => {

        let procOutput = async (data) => {
            data = data.toString();
            let points = Array.from(parseData(data));

            // check if no point - signal lost etc.
            if (points.length === 0 && !noPiontsTimeout) {
                // wait
                noPiontsTimeout = setTimeout(() => {
                    airodump.stdin.end();
                    airodump.kill();

                    console.log('Point lost');

                }, 30 * 1000);
            } else if (points.length !== 0) {
                // point appeared
                clearTimeout(noPiontsTimeout);
            }
        };

        airodump.stdout.on('data', async (data) => { await procOutput(data); });
        airodump.stderr.on('data', async (data) => { await procOutput(data); });

        airodump.on('error', (err) => { console.log(err); });

        airodump.on('close', (code) => { res(); });
    });
};

// sleep
let sleep = async (seconds) => { return new Promise((res, rej) => { setTimeout(function(){ res(); }, seconds * 1000); }); };

// run
(async () => {

    // init monitor mode
    let MonitorMode = await InitMonitorMode();
    let isInMonitorMode = await MonitorMode.start();

    if (!isInMonitorMode) {
        throw new Error('Can\'t enable monitor mode iface');
    }

    while (true) {

        // get open point
        let openPoint = await getOpenPoint().catch((err) => {
            console.log('ERROR:', err);
        });

        if (openPoint) {
            console.log('Capture - '+ openPoint.essid);

            // capture traffic until signal lost, point disappear etc
            await capture(openPoint);

        } else { // on error
            let sleepTime = 60;

            console.log('No open points, wait '+ sleepTime +' sec');
            await sleep(sleepTime);
        }

        await sleep(1);
    }

})();